! gfortran -O2 -Wall -Wextra -o test-rnd-run-bits test-rnd-run-bits.f90 test-rnd.f90 -lrt
! Runtime checks: gfortran -O2 -Wall -Wextra -fsanitize=undefined -o test-rnd-run-bits test-rnd-run-bits.f90 test-rnd.f90 -lrt
! ./test-rnd-run >(head -c 12 | xxd -b -g 0 -c 3 1>&2) | head -20
! ./test-rnd-run >(head -c 12 | xxd -b -g 0 -c 3 1>&2) >/dev/null
! ./test-rnd-run >(head -c1M | md5sum)
! timeout 10 ./test-rnd-run >(pv >/dev/null)
! time ./test-rnd-run >(PractRand-RNG_test stdin -tlmax 4G -multithreaded)

program test_rnd_run
  use types_const, only: dp, missing
  use test_rnd
  implicit none

  integer                         :: num_args
  character(len=1024)             :: filename, bits_string, progname, bytes_requested_string
  integer, parameter              :: size=4096
  integer(kind=4), dimension(:), allocatable :: j
  integer(kind=1), dimension(:), allocatable :: d
  integer(kind=1)                 :: carry
  integer(kind=4)                 :: carry_bits, top_bit, bits
  type(t_rnd_state), dimension(1) :: s
  real(dp)                        :: x, y
  integer(kind=4)                 :: i, target_bits, target_bytes, source_words, error, k, source
  integer(kind=8),dimension(2)    :: ccount, count_rate, count_max
  integer(kind=8)                 :: bytes_requested, steps, l

  num_args = command_argument_count()

  if (num_args /= 3) then
   print *, "Expecting three arguments"
   call get_command_argument(0, progname)
   print "(a10,a)", progname, "bits size(GiB) filename"
   print *, "          bits       ... How many bits to use from rnd output. Supported range 1..24"
   print *, "          size(GiB)  ... How many GiB to generate. 0 means endless stream of random bytes"
   print *, "          filename   ... write random bytes to filename. Use process substitution in shell"
   print *, "                         to send output to another process"
   print "(a,a)", progname, "0 >(pv >/dev/null)"
   stop 1
  end if
  call get_command_argument(1, bits_string)
  read(bits_string,*)bits
  if (bits > 32 .or. bits < 1) then
   print *, "bits has to be in range 1 - 32"
   stop 1
  end if

  call get_command_argument(2, bytes_requested_string)
  read(bytes_requested_string,*)bytes_requested
  bytes_requested = bytes_requested * 1024 * 1024 * 1024

  call get_command_argument(3, filename)
  ! asynchronous='yes' breaks the order!
  open(file=filename, unit=8, access="stream",form="unformatted", action='write')
  call rnd_init(s)

  target_bits = lcm(8,bits)
  target_bytes = target_bits/8
  source_words = target_bits/bits

  allocate( d(target_bytes*size), j(source_words), stat=error)
  if ( error /= 0 ) then
      print *, "Cannot allocate arrays."
      stop
  end if
  
  if (bytes_requested>0) then
    !ceiling integer division
    steps = ( bytes_requested + target_bytes*size - 1 ) / (target_bytes*size)
  else
    steps = huge(steps)
  endif

  ! On Linux, link with -lrt to get nanosecond precision
  call system_clock(ccount(1), count_rate(1), count_max(1))
  do l=1,steps
    do i=1,size
      
      do k=1, source_words
        call ran1(s(1),x)
        j(k) = INT(x*16777216,4)
      end do

      source=1
      top_bit=bits

      do k=1, target_bytes
        if(top_bit>7) then
          top_bit = top_bit - 8
          d(target_bytes*(i-1)+k) = INT(IBITS(j(source), top_bit, 8),1)
        else
          carry =  INT(ISHFT(IBITS(j(source), 0, top_bit),8-top_bit),1)
          carry_bits = top_bit
          do while (carry_bits<8)
            source = source + 1
            top_bit = bits
            if(top_bit>=8-carry_bits) then
              top_bit = top_bit + carry_bits -8
              d(target_bytes*(i-1)+k) = IOR(carry,INT(IBITS(j(source), top_bit, 8-carry_bits),1))
              exit
            else
              carry = IOR(carry, INT(ISHFT(IBITS(j(source), 0, top_bit),8-carry_bits-top_bit),1))
              source = source + 1
              top_bit = bits
              carry_bits = carry_bits + top_bit
            end if
          end do  
        end if
      end do
      
    end do
    write(8) d(1:target_bytes*size)
  end do

  close(8)

  call system_clock(ccount(2), count_rate(2), count_max(2))
  x = target_bytes*size*steps / 1024.0D0 / 1024.0D0 / 1024.0D0
  y = (ccount(2)-ccount(1)) / 1000.0D0 / 1000.0D0 / 1000.0D0
  j(1) = d(target_bytes*size)
  if (j(1)<0) then
    j(1) = 256 + j(1)
  endif
  print *, "Generated ", x, "random GiB in ", y, "seconds, last generated byte is ", j(1)
  x = x / y * 1024.0D0
  print *, x, "MiB/s"

contains

  integer (kind=4) function lcm(a,b)
    implicit none
    integer (kind=4), intent(in) :: a,b
    lcm = a*b / gcd(a,b)
  end function lcm

  integer (kind=4) function gcd(a,b)
    implicit none
    integer (kind=4), intent(in) :: a,b
    integer (kind=4) :: aa,bb,t
    aa = a
    bb = b
    do while (bb/=0)
      t = bb
      bb = mod(aa,bb)
      aa = t
    end do
    gcd = abs(aa)
  end function gcd

end program test_rnd_run
